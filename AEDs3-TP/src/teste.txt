private static void intercalacaoBalanceada(String[] inputFiles, int m, int n) throws IOException {
		//variaveis usadas no geral
		CRUD crud = new CRUD("../data/arquivo.bin");
		int maxId = crud.getMaxId() + 1;
		int inputAmount = inputFiles.length - 2;

		//objetos filmes usados na ordenação externa
		Movie j_temp1 = new Movie();
		Movie j_temp2 = new Movie();

		//variaveis usadas para controlar o for
		int passadas = calcularPassadas(m, n);
		int regPorArq = (int) (Math.ceil((float) maxId / (float) m)/2)*m;//quantidade de registros em cada arquivo
		//int diferenca = (regPorArq * (n + 2)) - maxId;//diferenca que pode ter em arquivo

		int scr = 0; //variavel socorro, alguem me ajuda por favor
		while (scr <= maxId){
			scr = scr + m;
		}
		scr -= m;
		int diferenca = maxId - scr;


		int quantBloco = (int)Math.ceil((double)(regPorArq)/(double)m);//quantidade de blocos em cada arquivo
		//System.out.println("quant bloco antes = " + quantBloco);
		int interiorBloco = m;

		//variaveis usadas para fazer a ordenação externa
		byte ba1[];
		byte ba2[];
		int controle1, controle2 = 0, controle3 = 0;//usadas para saber qual arquivo abrir
		int pos1  = 4, pos2 = 4;//usadas para saber se mudou o registro que vai comparar
		int posOut1  = 4, posOut2 = 4;
		int tamanho = 0;
		int count1 = 0, count2 = 0;
		boolean condicao1 = false, condicao2 = false;

		//for de cada fase
		for (int i = 0; i < passadas; i++) {
			posOut1 = 4;
			posOut2 = 4;//resetar pra nova passada
			pos1 = 4;
			pos2 = 4;//resetar pra nova passada

			//System.out.println("passadas = " + i);
			
			//for de cada bloco
			for (int k = 0; k < quantBloco; k++) {	
                //for do interior de cada bloco	
				for (int j = 0; j < interiorBloco || ((count1+count2) < interiorBloco); j++) {			

					//arquivo de saída e entrada
					RandomAccessFile raf1   = new RandomAccessFile(inputFiles[controle1    ], "r" );
					RandomAccessFile raf2   = new RandomAccessFile(inputFiles[controle1 + 1], "r" );
					RandomAccessFile rafOut = new RandomAccessFile(inputFiles[controle2    ], "rw");

					if (((count1 < interiorBloco) || raf1.getFilePointer() + 1 < raf1.length())){
						condicao1 = true;
					} else {
						condicao1 = false;
					}
					if (((count2 < interiorBloco) || raf2.getFilePointer() + 1 < raf2.length())){
						condicao2 = true;
					} else {
						condicao2 = false;
					}

					raf1.seek(0);
					int size1 = raf1.readInt();
					raf2.seek(0);
					int size2 = raf2.readInt();

                    
					if ((k == quantBloco-1) && ((size1 + (diferenca) == regPorArq) || (size1 - (diferenca)== regPorArq))){
						System.out.println("AAA");

						if ((size1 + (diferenca) == regPorArq)){
							condicao1 = ((count1 < ((interiorBloco) - (diferenca)) ) && (raf1.getFilePointer() < raf1.length() - 6));
							System.out.println("AAA1");

						}else {
							condicao1 = ((count1 < ((interiorBloco) + (diferenca)) ) && (raf1.getFilePointer() < raf1.length() - 6));
							System.out.println("AAA2");

						}
						//condicao2 = (count2 < interiorBloco-1);
					} else if ((k == quantBloco-1) && ((size2 + (diferenca) == regPorArq) || (size2 - (diferenca) == regPorArq))){
						//System.out.println("bfjkldsafkljsadklfjalksfjlkasfjlk");
						System.out.println("BBB");

						//condicao1 = (count1 < interiorBloco-1);
						if (size2 + (diferenca) == regPorArq){
							condicao2 = ((count2 < ((interiorBloco) - (diferenca)) ) && raf2.getFilePointer() < raf2.length() - 6);
							System.out.println("BBB1");

						} else {
							condicao2 = ((count2 < ((interiorBloco) + (diferenca)) ) && raf2.getFilePointer() < raf2.length() - 6);
							System.out.println("BBB2");

						}
					}

                    raf1.seek(pos1);
					raf2.seek(pos2);

                    //apontar corretamente pra posicao do rafOut
					if (k % 2 == 0) {
						rafOut.seek(posOut1);//se for par continua de onde parou anteriormente
					} else {
						rafOut.seek(posOut2);//se for impar continua de onde parou anteriormente
					}

                    if (condicao1 && condicao2){//se o primeiro existir
                        tamanho = raf1.readInt();
                        ba1 = new byte[tamanho];					
						raf1.read(ba1);
                        j_temp1.fromByteArray(ba1);//transformando em objeto

                        tamanho = raf2.readInt();
                        ba2 = new byte[tamanho];					
						raf2.read(ba1);
                        j_temp2.fromByteArray(ba2);//transformando em objeto

                        if (j_temp1.id < j_temp2.id){				 
                            pos1 = writeOutput(pos1, j_temp1, rafOut);//escrever no arquivo de output
                            controle3++;
                            count1++;
                        } else {
                            pos2 = writeOutput(pos2, j_temp2, rafOut);//escrever no arquivo de output
                            controle3++;
                            count2++;
                        }
                    } else if (condicao1){
                        tamanho = raf1.readInt();
                        ba1 = new byte[tamanho];					
						raf1.read(ba1);
                        j_temp1.fromByteArray(ba1);//transformando em objeto
                        pos1 = writeOutput(pos1, j_temp1, rafOut);//escrever no arquivo de output
                        controle3++;
                        count1++;
                    } else if (condicao2){
                        tamanho = raf2.readInt();
                        ba2 = new byte[tamanho];					
						raf2.read(ba1);
                        j_temp2.fromByteArray(ba2);//transformando em objeto
                        pos2 = writeOutput(pos2, j_temp2, rafOut);//escrever no arquivo de output
                        controle3++;
                        count2++;
                    }

                    if (k % 2 == 0) {
                        posOut1 = (int)(rafOut.getFilePointer());//salvar na variavel 1 se for par
                    } else {
                        posOut2 = (int)(rafOut.getFilePointer());//salvar na variavel 2 se for impar
                    }

                    raf1.close();
                    raf2.close();
                    rafOut.close();



                
                }

                count1 = 0;
				count2 = 0;
                
            }//fim for de cada bloco
			
			interiorBloco = interiorBloco*n;//mudar o tamanho de cada bloco de acordo com a fase
			quantBloco = (int)Math.ceil((double)regPorArq/(double)interiorBloco);//mudar a quantidade de blocos por arquivo de acordo com a fase
	}
    crud.mostrarTudo(inputFiles[controle2], 4);
}